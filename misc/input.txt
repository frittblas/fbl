// D-pad directions.
#define D_NEUTRAL 0
#define D_UP 1
#define D_DOWN 2
#define D_LEFT = 4
#define D_RIGHT = 8
#define D_UP_LEFT (D_UP | D_LEFT)
#define D_UP_RIGHT (D_UP | D_RIGHT)
#define D_DOWN_LEFT (D_DOWN | D_LEFT)
#define D_DOWN_RIGHT (D_DOWN | D_RIGHT)

// Buttons.
#define B_LP 16
#define B_MP 32
#define B_HP 64
#define B_LK 128
#define B_MK 256
#define B_HK 512
#define B_ANY_P (B_LP | B_MP | B_HP)
#define B_ANY_K (B_LK | B_MK | B_HK)
#define B_THROW (B_LP | B_LK)
#define B_UOH (B_MP | B_MK)

// 60 FPS. Maximum move needs 2 sec charge.
#define KB_LENGTH 2 * 60

// Array of keys pressed every frame for the last 2 seconds.
ui16 key_buffer[KB_LENGTH];

// This happens every frame.
get_joypad_state() {
// Shift all the keys down a frame to make way for the new one.
// Newest keypresses are at the top ie. key_buffer[0]
for(i = KB_LENGTH - 1; i > 0; i--)
key_buffer = key_buffer[i - 1];

// Get an int with flags for all active buttons.
key_buffer[0] = (ui16) ReadKeyStateFromHardware();
}

// Input commands are back to front. This is easier to check for in the buffer.
// Allows us to reject bad moves faster.
// All moves done facing right. Very easy to work around this for Player 2.
// First value = frames leeway. Second value = required inputs
ui16 overhead[] = {
10, B_UOH,
10, B_NEUTRAL
};

// Only 3 frame leeway. Dashes gotta input be fast.
ui16 dash[] = {
3, D_RIGHT,
3, D_RIGHT,
3, D_NEUTRAL
};

ui16 qcf[] = {
10, B_ANY_P,
10, D_RIGHT,
10, D_DOWN_RIGHT,
10, D_DOWN
};

ui16 dpm[] = {
10, B_ANY_P,
10, D_DOWN_RIGHT,
10, D_DOWN,
10, D_RIGHT
};

ui16 sgs[] = {
10, B_LK | B_HP,
10, D_RIGHT,
10, B_LP,
10, B_LP
};

ui16 sonic_boom[] = {
10, D_RIGHT | B_ANY_P,
5, D_LEFT,
5, D_LEFT,
// ...	(until sum(leeway) == 120 [ie. 2 seconds])
};

bool look_for_move(ui16 *move, int entries) {
for(int i = j = k = 0; i < KB_LENGTH; i++, j++) {
if(move[k + 1] == D_NEUTRAL) {	// Not working exactly as per 3S.
if(key_buffer & (D_DOWN | D_UP | D_LEFT | D_RIGHT) == 0) {
// Found correct press at right time. Look for next one.
j = 0;
k += 2;
}
}

// FIXME: ANY_P and ANY_K won't register unless ALL P or ALL K pressed. My bad.
else if((key_buffer & move[k + 1]) == move[k + 1]) {
// Found correct press at right time. Look for next one.
j = 0;
k += 2;
}

if(k == entries) // The move was found!
return true;

if(j == move[k]) // Move not found, or input not quick enough.
return false;
}

return false;
}

...

// You can then test for moves by calling..
if(look_for_moves(sonic_boom, sizeof(sonic_boom) / sizeof(ui16)) {
// Add projectile etc.
play_funky_sound("sonic_bin.mid");
}

look_for_moves(dpm, sizeof(dpm) / sizeof(ui16);